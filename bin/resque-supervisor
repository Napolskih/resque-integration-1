#!/usr/bin/env ruby
# coding: utf-8

require 'optparse'
require 'ostruct'
require 'logger'
require 'resque'

class Supervisor < OpenStruct
  def start
    logger.warn 'Supervisor already running' and return if running?
    logger.info 'Starting supervisor...'

    Process.daemon if detach

    File.write(pid_file, Process.pid)
    Resque.redis = "#{host}:#{port}:#{db}/#{namespace}"

    trap('QUIT') { remove_pid; exit }


    loop do
      Resque.workers.each(&:prune_dead_workers)

      sleep 30
    end
  end

  def stop
    unless running?
      logger.warn 'Supervisor is not running'
      remove_pid

      return
    end

    Process.kill('QUIT', pid)
  end

  def running?
    pid && Process.kill(0, pid)
  rescue Errno::ESRCH
    false
  end

  private
  def pid
    File.exists?(pid_file) ? File.read(pid_file).chomp.to_i : nil
  end

  def remove_pid
    File.delete(pid_file) if File.exists?(pid_file)
  end

  def logger
    @logger ||= Logger.new(log_file || '/dev/null').tap do |logger|
      logger.formatter = proc do |severity, datetime, progname, msg|
        "%-5s %-5s %s: %s\n" % [$$, severity, datetime, msg]
      end
    end
  end
end

supervisor = Supervisor.new(
    :host => 'localhost',
    :port => 6379,
    :db => 0,
    :namespace => 'resque',
    :pid_file => File.join(File.dirname(__FILE__), 'resque-supervisor.pid')
)

OptionParser.new do |opts|
  opts.banner = 'Usage: resque-supervisor [options] [start|stop|restart]'

  opts.on('-h', '--host [HOST]', 'Redis host') do |h|
    supervisor.host = h
  end

  opts.on('-p', '--port [PORT]', 'Redis namespace') do |p|
    supervisor.port = p.to_i
  end

  opts.on( '--db [DB]', 'Redis DB no') do |d|
    supervisor.db = d.to_i
  end

  opts.on('-d', '--[no-]detach', 'Run as daemon') do |v|
    supervisor.detach = v
  end

  opts.on('-i', '--pid [FILE]', 'pid file') do |r|
    supervisor.pid_file = r
  end

  opts.on('-l', '--log [FILE]', 'log file') do |f|
    supervisor.log_file = f
  end

  opts.on('-n', '--namespace [NAMESPACE]', 'Resque namespace') do |n|
    supervisor.namespace = n
  end

  opts.on_tail('--help', 'Show this message') do
    puts opts
    exit(1)
  end
end.parse!(ARGV)

command = ARGV.shift

if %w(start stop).include?(command)
  supervisor.send(command)
end